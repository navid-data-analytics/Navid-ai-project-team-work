package vault

import (
	"context"
	"crypto/tls"
	"reflect"
	"sync"
	"time"

	"github.com/hashicorp/vault/api"
)

var (
	idLock    = sync.Mutex{}
	idCounter int64
)

// Secret is the interface all secrets conform to
type Secret interface {
	ID() int64
	VaultID() string
	ExpireTime() time.Time
	RenewTime() time.Time
	CreateTime() time.Time
	ExpireContext() context.Context
	RenewContext() context.Context
	Cancel()
	Valid() bool
}

// Assert StandardSecret conforms to Secret interface
var _ = Secret(&StandardSecret{})

//nilSecret is a utility function to tell whether a secret does not exist as interfaces are (val,type) pairs in go
func nilSecret(secret Secret) bool {
	return secret == nil || reflect.ValueOf(secret).IsNil()
}

// StandardSecret is the exposed abstraction of a vault secret
type StandardSecret struct {
	api.Secret
	CreatedAt       time.Time
	expireCtx       context.Context
	expireCtxCancel context.CancelFunc
	renewCtx        context.Context
	renewCtxCancel  context.CancelFunc
	parent          Secret
	id              int64
}

// ID returns the secrets autogenerated unique ID
func (ss *StandardSecret) ID() int64 {
	return ss.id
}

// VaultID returns the secrets vault lease ID
func (ss *StandardSecret) VaultID() string {
	// if lease id is zero and auth is present, assume this is an authentication secret
	if ss.LeaseID == "" && ss.Auth != nil {
		return ss.Auth.ClientToken
	}
	return ss.LeaseID
}

// RenewTime returns the time the user should assume this secret has expired
func (ss *StandardSecret) RenewTime() time.Time {
	lease := ss.leaseDuration()
	return ss.CreatedAt.Add(lease - time.Minute)
}

// ExpireTime returns the time the user should assume this secret has expired
func (ss *StandardSecret) ExpireTime() time.Time {
	lease := ss.leaseDuration() - time.Second // -1 second to prevent lease from ever actually expiring in vault before in service
	return ss.CreatedAt.Add(lease)
}

// CreateTime returns the time the user should assume this secret was created
func (ss *StandardSecret) CreateTime() time.Time {
	return ss.CreatedAt
}

// ExpireContext returns a context that is canceled when either ExpireTime passes or the parents ExpireContext is canceled
func (ss *StandardSecret) ExpireContext() context.Context {
	return ss.expireCtx
}

// RenewContext returns a context that is canceled when either RenewTime passes or the parents RenewContext is canceled
func (ss *StandardSecret) RenewContext() context.Context {
	return ss.renewCtx
}

// Cancel cancels all acquired contexts on this secret
func (ss *StandardSecret) Cancel() {
	ss.renewCtxCancel()
	ss.expireCtxCancel()
}

// Valid returns true if this secret can still be used
func (ss *StandardSecret) Valid() bool {
	select {
	case <-ss.expireCtx.Done():
		// false if expired or parent expired
		return false
	default:
		return true
	}
}

func (ss *StandardSecret) leaseDuration() time.Duration {
	leaseDuration := ss.LeaseDuration

	// if lease duration is zero and auth is present, assume this is an authentication secret
	if leaseDuration == 0 && ss.Auth != nil {
		leaseDuration = ss.Auth.LeaseDuration
	}

	return time.Duration(leaseDuration) * time.Second
}

// NewStandardSecret creates a secret from vault api secret
func NewStandardSecret(secret *api.Secret, parent Secret) *StandardSecret {
	idLock.Lock()
	idCounter++
	newID := idCounter
	idLock.Unlock()

	ss := &StandardSecret{
		Secret:    *secret,
		parent:    parent,
		CreatedAt: time.Now(),
		id:        newID,
	}

	var parentCtx context.Context
	if nilSecret(ss.parent) {
		parentCtx = context.Background()
	} else {
		// require renewal for secrets when parent secret expires
		parentCtx = parent.ExpireContext()
	}

	ss.renewCtx, ss.renewCtxCancel = context.WithDeadline(parentCtx, ss.RenewTime())
	ss.expireCtx, ss.expireCtxCancel = context.WithDeadline(parentCtx, ss.ExpireTime())

	return ss
}

// Assert StandardSecret conforms to Secret interface
var _ = Secret(&UserPassSecret{})

// UserPassSecret contains credentials with user and password.
// Additionally it contains metadata about the current secret in vault
type UserPassSecret struct {
	StandardSecret
	Credentials UserPassCredentials
}

// NewUserPassSecret returns a new secret with username and password taken from the vault secret data.
// Generally you should not need to call this outside of this package,
// it is exposed for use in tests with mocked clients in other packages.
func NewUserPassSecret(secret *StandardSecret) (*UserPassSecret, error) {
	user, err := stringOrError(secret, SecretDataKeyUsername, ErrEmptySecretUsernameData, ErrInvalidSecretUsernameFormat)
	if err != nil {
		return nil, err
	}

	password, err := stringOrError(secret, SecretDataKeyPassword, ErrEmptySecretPasswordData, ErrInvalidSecretPasswordFormat)
	if err != nil {
		return nil, err
	}

	return &UserPassSecret{
		StandardSecret: *secret,
		Credentials: UserPassCredentials{
			User:     user,
			Password: password,
		},
	}, nil
}

// Assert StandardSecret conforms to Secret interface
var _ = Secret(&TLSCertSecret{})

// TLSCertSecret contains a secret with TLS certificate.
// Additionally it contains metadata about the current secret in vault
type TLSCertSecret struct {
	StandardSecret
	Certificate *tls.Certificate
}

// NewTLSCertSecret returns a new secret with tls certificate parsed from the secrets.
// Generally you should not need to call this outside of this package,
// it is exposed for use in tests with mocked clients in other packages.
func NewTLSCertSecret(certSecret, keySecret *StandardSecret) (*TLSCertSecret, error) {
	certStr, err := stringOrError(certSecret, SecretDataKeyData, ErrEmptySecretTLSCertData, ErrInvalidSecretTLSCertFormat)
	if err != nil {
		return nil, err
	}

	keyStr, err := stringOrError(keySecret, SecretDataKeyData, ErrEmptySecretTLSCertKeyData, ErrInvalidSecretTLSCertKeyFormat)
	if err != nil {
		return nil, err
	}

	cert, err := tls.X509KeyPair([]byte(certStr), []byte(keyStr))
	if err != nil {
		return nil, err
	}

	secret := minByLeaseDuration(certSecret, keySecret)
	return &TLSCertSecret{
		StandardSecret: *secret,
		Certificate:    &cert,
	}, nil
}

// AWSSecret contains the aws credentials returned by STS
type AWSSecret struct {
	StandardSecret
	Credentials STSCredentials
}

// NewAWSSecret returns a new secret with access key, secret key and security token taken from the secret.
func NewAWSSecret(secret *StandardSecret) (*AWSSecret, error) {
	accessKey, err := stringOrError(secret, SecretDataKeyAccessKey, ErrEmptySecretAccessKeyData, ErrInvalidSecretAccessKeyFormat)
	if err != nil {
		return nil, err
	}

	secretKey, err := stringOrError(secret, SecretDataKeySecretKey, ErrEmptySecretSecretKeyData, ErrInvalidSecretSecretKeyFormat)
	if err != nil {
		return nil, err
	}

	securityToken, err := stringOrError(secret, SecretDataKeySecurityToken, ErrEmptySecretSecurityTokenData, ErrInvalidSecretSecurityTokenFormat)
	if err != nil {
		return nil, err
	}

	return &AWSSecret{
		StandardSecret: *secret,
		Credentials: STSCredentials{
			AccessKey:     accessKey,
			SecretKey:     secretKey,
			SecurityToken: securityToken,
		},
	}, nil
}

func minByLeaseDuration(s1, s2 *StandardSecret) *StandardSecret {
	if s1.RenewTime().Before(s2.RenewTime()) {
		return s1
	}
	return s2
}

func stringOrError(secret *StandardSecret, key string, errEmptySecret, errInvalidSecret error) (string, error) {
	entry, ok := secret.Data[key]
	if !ok {
		return "", errEmptySecret
	}
	str, ok := entry.(string)
	if !ok {
		return "", errInvalidSecret
	}
	return str, nil
}
